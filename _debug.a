

%imacro TODO_BitmapAllocBottom 0
	PUSH ECX
	PUSH EDX
	PUSH EBX
	XOR EAX,EAX
	MOV ECX,0x80000/0x1000; up to 0x00010000
	%%Lup:
	BTS [EBX],EAX
	JNC %%Fin
	INC EAX
	LOOP %%Lup
	; ALL OCCUPIED
	XOR EAX,EAX
	%%Fin:
	SHL EAX,12
	POP EBX
	POP EDX
	POP ECX
%endmacro
%imacro TODO_BitmapAllocBottomUser 0;
	PUSH ECX
	PUSH EDX
	PUSH EBX
	MOV EAX,0x10_0000/0x1000
	MOV ECX,0x30_0000/0x1000; available : 4MB-1MB
	%%Lup:
	BTS [EBX],EAX
	JNC %%Fin
	INC EAX
	LOOP %%Lup
	; ALL OCCUPIED
	XOR EAX,EAX
	%%Fin:
	SHL EAX,12
	POP EBX
	POP EDX
	POP ECX
%endmacro
%imacro TODO_BitmapAllocBottom16 0
	PUSH CX
	PUSH DX
	PUSH BX
	XOR AX,AX
	MOV CX,0x80000/0x1000
	%%Lup:
	BTS [BX],AX
	JNC %%Fin
	INC AX
	LOOP %%Lup
	; ALL OCCUPIED
	XOR AX,AX
	%%Fin:
	SHL AX,12
	POP BX
	POP DX
	POP CX
%endmacro

; 暂时没有BitmapAllocBottom失败检查
%imacro TODO_PageRegister 0; make ds -> glb
	; If the page item exists, do not do any.
	PUSH EAX
	PUSH EBX
	PUSH ESI
	;CHK PAGE TABLE PRESENT
	MOV ESI,EBX
	AND ESI,0xFFC00000
	SHR ESI,20; SHR22&&SHL2
	OR ESI,0xFFFFF000; PAGE DIRECTORY
	TEST DWORD[ESI],1; PRESENT BIT
	JNZ %%NEXT
	;CREATE PAGED, WHICH IS BOUND TO LACK FOR P BIT
	CALL %%F_BitmapAllocBottom
	OR EAX,3; US=S RW P
	MOV [ESI],EAX
	%%NEXT:
	MOV ESI,EBX
	SHR ESI,10
	AND ESI,0x003FF000
	OR ESI,0xFFC0_0000; PAGETABLE no LinearAddr
	AND EBX,0x003FF000
	SHR EBX,10
	OR ESI,EBX
	TEST DWORD[ESI],1; PRESENT BIT
	JNZ %%ENDM; need not create page table (item of what page dir pointed)

	CALL %%F_BitmapAllocBottom
	OR EAX,3; US=S RW P
	MOV [ESI],EAX; REGISTER
	JMP %%ENDM
	%%F_BitmapAllocBottom:
		PUSH EBX
		MOV EBX,0x8008_0000
		BitmapAllocBottom
		POP EBX
		RET
	%%ENDM:
	POP ESI
	POP EBX
	POP EAX
%endmacro
%imacro TODO_PageRegisterUser 0; look above
	; If the page item exists, do not do any.
	PUSH EAX
	PUSH EBX
	PUSH ESI
	;CHK PAGE TABLE PRESENT
	MOV ESI,EBX
	AND ESI,0xFFC00000
	SHR ESI,20; SHR22&&SHL2
	OR ESI,0xFFFFF000; PAGE DIRECTORY
	TEST DWORD[ESI],1; PRESENT BIT
	JNZ %%NEXT
	;CREATE PAGED, WHICH IS BOUND TO LACK FOR P BIT
	CALL %%F_BitmapAllocBottom
	OR EAX,7; US=User RW P
	MOV [ESI],EAX
	%%NEXT:
	MOV ESI,EBX
	SHR ESI,10
	AND ESI,0x003FF000
	OR ESI,0xFFC0_0000; PAGETABLE no LinearAddr
	AND EBX,0x003FF000
	SHR EBX,10
	OR ESI,EBX
	TEST DWORD[ESI],1; PRESENT BIT
	JNZ %%ENDM; need not create page table (item of what page dir pointed)

	CALL %%F_BitmapAllocBottom
	OR EAX,7; US=User RW P
	MOV [ESI],EAX; REGISTER
	JMP %%ENDM
	%%F_BitmapAllocBottom:
		PUSH EBX
		MOV EBX,0x8008_0000
		BitmapAllocBottomUser
		POP EBX
		RET
	%%ENDM:
	POP ESI
	POP EBX
	POP EAX
%endmacro


%imacro TSSStruct_Mecocoa 0
 ;暂没有对memalloc进行回应
 ;---SubLDT---
 ;------LDTE 00 Header
 ;------LDTE 01 Code
 ;------LDTE 02 Data
 ;------LDTE 03 Ronl
 ;------LDTE 04 SS0 4k
 ;------LDTE 05 SS1 4k
 ;------LDTE 06 SS2 4k
 ;------LDTE 07 SS3 4nk
 ;---------
	PUSHAD
	MOV EBP,ESP
	MOV ECX,512
	CALL %%CallMemAlloc
	MOV ESI,EAX
	MOV [EBP+4*4],EAX; Return Value(EBX)
	MOV EBX,EAX
	MOV EAX,[EBP+9*4]
	; DFLoad
		PUSHAD; 内存连续性检查连续性 暂无
			CALL %%F_DiskReadLBA28
			SUB EBX,512
			MOV ECX,DWORD[DS:EBX]
			ADD ECX,511
			AND ECX,0xFFFF_FE00; shr9 & shl9
			MOV DWORD[DS:EBX],ECX
			SUB ECX,512
			JZ %%F_ENDO
				INC EAX
				PUSH EAX
				CALL %%CallMemAlloc
		MOV EBX,EAX; ~= ADD EBX,512
		POP EAX
		SHL ECX,9
		%%READLOOP:
			PUSH ECX
			CALL %%F_DiskReadLBA28
			INC EAX
			POP ECX
			LOOP %%READLOOP
			JMP %%F_ENDO
		%%F_DiskReadLBA28:
		HdiskLoadLBA28 EAX,1
		RET
		%%F_ENDO:
		POPAD
	MOV WORD[ESI+98],-1; LDT length 0
	; {ESI=HEADER_ADDR}
 ; CLEAR PAGEDIR USER PART; When switch takes or suspend a task, make a copy of User 512B PDir.
	; ; MOV EBX,0xFFFFF000
	; ; XOR EDI,EDI
	; ; MOV ECX,512
	; ; %%PD_USER_CLR:
	; ; 	MOV DWORD[EBX+EDI*4],0
	; ; 	INC EDI
	; ; LOOP %%PD_USER_CLR
 ; SETUP HEADER #00
	MOV EAX,ESI
	MOV EBX,256-1
	MOV ECX,0x0040F200; [Byt][32][KiSys][DATA][R3][读写/读执]
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR CX,3; SET RING3
 PUSH CX; ES
	; MOV WORD[ESI+72],CX; ES

 ; JUDGE MAGIC NUMBER
	CMP WORD[ESI+10],0x32DE
	JZ %%NEXT1
	%%ERR:
	MOV DWORD[EBP+4*4],1; 0
	JMP %%Endo
	%%NEXT1:

 ; SETUP LDT CODE SEGM
	MOV EAX,[ESI+76]
	ADD EAX,ESI
	MOV EBX,[ESI+72]
	DEC EBX
	MOV ECX,0x0040F800; [Byt][32][KiSys][CODE][R3][只读/只执]
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR CX,3; SET RING3
	MOV WORD[ESI+76],CX; CS
	POP CX
	MOV WORD[ESI+72],CX

 ; SETUP LDT DATA SEGM
	MOV EAX,[ESI+84]
	ADD EAX,ESI
	MOV EBX,[ESI+80]
	DEC EBX
	MOV ECX,0x0040F200; [Byt][32][KiSys][DATA][R3][读写/读执]
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR CX,3; SET RING3
	MOV WORD[ESI+84],CX; DS
 ; SETUP LDT RONL SEGM
	MOV EAX,[ESI+92]
	ADD EAX,ESI
	MOV EBX,[ESI+88]
	DEC EBX
	MOV ECX,0x0040F000; [Byt][32][KiSys][DATA][R3][只读/只执]
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR CX,3; SET RING3
	MOV WORD[ESI+92],CX; GS
 ; SETUP LDT STACK 0~2 SEGM
	XOR EDI,EDI
	MOV ECX,3
	%%NEXT2:
	PUSH ECX
	MOV ECX,0x1000; 4K
	CALL %%CallMemAlloc
	ADD EAX,ECX; STACK BASE FROM HIGH END
	MOV EBX,0xFFFFE; 4K
	MOV ECX,00C09600H; [4KB][32][KiSys][DATA][R0][读写下拓/读执依从]
	OR EDI,EDI
	JZ %%NEXT3
	PUSH ECX
	PUSH EBP
		MOV ECX,EDI
		%%NEXT4:
		;ADD ECX,2000H; STEP RING; Error fix RFQ27:18:16
		MOV EBP,ESP
		ADD DWORD[EBP],2000H
		LOOP %%NEXT4
	POP EBP
	POP ECX
	%%NEXT3:
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR ECX,EDI; ring
		PUSH EDI; TSS to fill
		SHL EDI,3
		ADD EDI,ESI
		MOV DWORD[EDI+4],0
		MOV WORD[EDI+8],CX
		POP EDI
	INC EDI
	POP ECX
	LOOP %%NEXT2

 ; SETUP LDT STACK 3 SEGM
	MOV EBX,0x000_FFFFF
	MOV ECX,[ESI+56]
	ADD ECX,0x1000-1; align
	SHR ECX,3*4
	SUB EBX,ECX
	SHL ECX,3*4
	CALL %%CallMemAlloc; ecx -> eax
	ADD EAX,ECX
	MOV ECX,0x00C0F600; [4KB][32][KiSys][DATA][R3][读写下拓/读执依从]
	CALL %%F_GDTDptrStruct
	MOV EBX,ESI
	CALL %%F_LDTDptrAppend
	OR CX,3
	MOV WORD[ESI+80],CX
	MOV DWORD[ESI+56],0; ESP

 ; Other TSS
	MOV WORD[ESI],0; 反向链
	MOV WORD[ESI+2],0; AVAILABLE State

	; EFLAGS
	XOR EAX,EAX; RESET EFLAGS
	PUSHFD
	POP EAX
	MOV DWORD[ESI+36],EAX

	MOV WORD[ESI+100],0; T
	MOV WORD[ESI+102],104-1; I/O REF BASE (NON-EXIST)

	MOV WORD[ESI+88],0; FS
	MOV EAX,CR3
	MOV DWORD[ESI+28],EAX; PDBR	
 ; CR3 (Part 1/2) 暂时不隔离任务了，因为：
	;* App.a 既有app area又有krn area，比较混乱
	;* AdrPointerL 没设定好
	;* MemAlloc 没有为每个应用分别考虑且没有检查
	;* 0xFFFFF以上的段暂不支持
	; CALL %%M_CopyPDir; eax=PhizikAddr
 ; Register LDT & TSS
	SGDT [GDTDptr]
	MOV EBX,DWORD[GDTDptr+2]
	XOR EAX,EAX
	MOV AX,[GDTDptr]
	INC AX
	ADD EBX,EAX
	MOV WORD[ESI+96],AX; LDTSel

	PUSH EBX
	MOV EAX,ESI
	ADD EAX,104; LDT
	XOR EBX,EBX
	MOV BX,[ESI+98];94
	MOV ECX,0x00408200; [Byt][32][NaSys][DATA][R0][读写/读执]
	CALL F_GDTDptrStruct_32
	POP EBX
	GDTDptrAppend EDX,EAX

	PUSH EBX
	MOV EAX,ESI; TSS
	MOV EBX,104-1
	MOV ECX,0x00408900; TSS RING0
	CALL F_GDTDptrStruct_32
	POP EBX
	GDTDptrAppend EDX,EAX
	ADD WORD[GDTDptr],8*2
	LGDT [BaseLA+GDTDptr]
	MOV [ESI+48],ESI
	JMP %%Endo
	%%CallMemAlloc:
		PUSH EDI
		MOV EDI, RotMalloc
		CALL SegGate:0
		POP EDI
		RET
	%%F_LDTDptrAppend:
		LDTDptrAppend
		RET
	%%F_GDTDptrStruct:
		GDTDptrStruct EAX,EBX,ECX
		RET
	%%F_BitmapAllocBottom:
		PUSH EBX
		MOV EBX,0x8008_0000
		BitmapAllocBottomUser
		POP EBX
		RET
	%%M_CopyPDir:; in(void)-out(eax=PhizikAddr)~pres(ds=es=SegGlb)
		; 未测试
		PUSH ESI
		PUSH EDI
		PUSH EBX
		PUSH ECX
		CALL %%F_BitmapAllocBottom
		MOV EBX,EAX
		OR EBX,0X00000007
		MOV [0XFFFFFFF8],EBX
		MOV ECX,1024/2
		MOV ESI,0XFFFFF000; ESI=CrtPDirLinearAddr
		MOV EDI,0XFFFFE000; EDI=NewPDirLinearAddr
		XOR EBX,EBX
		%%M_CopyPDir_Zero:
			MOV [EDI],EBX
			ADD ESI,4
			ADD EDI,4
			LOOP %%M_CopyPDir_Zero		
		MOV ECX,1024/2    ; ECX=NumofItems
		CLD
		REPE MOVSD 
		POP ECX
		POP EBX
		POP EDI
		POP ESI
	%%Endo:
	POPAD
%endmacro

