
[BITS 32];--------------------------------
;[Procedure protect-32 mode] (Near)
F_GDTDptrStruct_32:
	GDTDptrStruct EAX,EBX,ECX
	RET
F_TSSStruct3:
	TSSStruct_Mecocoa
	RET 4*1
F_MemAllocSuperv:; DS:GlbArea ECX->EAX
	PUSH EBX
	OR ECX, ECX
	JZ R_MemAllocS_End
	MOV EAX, [THISF_ADR+SvpAllocPtr]
	MOV EBX, EAX
	ADD EBX, ECX
	CMP EBX, 0x7FFFF; demoPage {TODO ISSUE}
	JBE R_MemAllocS_Next
	XOR EAX, EAX
	JMP R_MemAllocS_End
	R_MemAllocS_Next:
	ADD DWORD[THISF_ADR+SvpAllocPtr], ECX
	DEC EBX
	AND EBX, 0xFFFFF000
	R_MemAllocS_Loop:
		CMP EBX, EAX
		JB R_MemAllocS_End; E.G. 0x1000 < 0x1001
		CALL RR_PageRegister
		CMP EBX, 0
		JZ R_MemAllocS_End
		SUB EBX, 0x1000
		JMP R_MemAllocS_Loop
	R_MemAllocS_End:
	POP EBX
	RET
	RR_PageRegister:
		PageRegister
		RET

;[Routines protect-32 mode]
APISymbolTable:; till Routine
	RoutineNo: DD (__Routine-rot0000)/8
	rot0000:; Terminate
		DD R_Terminate-__Routine
		DW SegRot,0
	rot0001:; PrintString (accept New Line)
		DD R_Print-__Routine
		DW SegRot,0
	rot0002:; Malloc
		DD R_Malloc-__Routine
		DW SegRot,0
	rot0003:; (waiting for adding)
		DD R_Mfree-__Routine
		DW SegRot,0
	rot0004:; DiskReadLBA28
		DD R_DiskReadLBA28-__Routine
		DW SegRot,0
	rot0005:; PrintDwordCursor
		DD R_PrintDwordCursor-__Routine
		DW SegRot,0
__Routine:
RoutineGate:; EDI=FUNCTION RoutIn:{DS=SegData}
	; PUSHAD
	PUSH DS
	PUSH EAX
	MOV EAX, SegData
	MOV DS, EAX
	CMP DWORD[THISF_ADR+RoutineNo], EDI
	JB RoutineGateEnd
	POP EAX
	CALL FAR [THISF_ADR+rot0000+EDI*8]
	RoutineGateEnd:
	POP DS
	; POPAD
	RETF
R_Terminate:; 00 and other rontine point to here
	PUSHFD
	POP EDX
	TEST DX, 0100_0000_0000_0000B
	JNZ NESTED_TASK
	JMP SegTSS:0
	RETF
	JMP GeneralExceptionHandler
	NESTED_TASK: IRETD
	RETF; for next calling the subapp
	ALIGN 16
R_Print:
	PUSH ES
	PUSH EAX
	PUSH EBX
	PUSH AX	
	MOV EAX, SegVideo
	MOV ES,EAX
	POP AX
	ConPrint ESI,~
	POP EBX
	POP EAX
	POP ES
	RETF
	ALIGN 16
R_Malloc:; ecx=length ret"eax=start" (user-area by manager)
	; return [THISF_ADR+RamAllocPtr]++
    PUSH EBX
    OR ECX, ECX
    JZ R_MemAlloc_End
    MOV EAX, [THISF_ADR+UsrAllocPtr]
    MOV EBX, EAX
    ADD EBX, ECX
    CMP EBX, 0x00400000; UserRight
    JBE R_MemAlloc_Next
    XOR EAX, EAX
    JMP R_MemAlloc_End
    R_MemAlloc_Next:
    ADD DWORD[THISF_ADR+UsrAllocPtr], ECX
    DEC EBX
    AND EBX,0xFFFFF000
    R_MemAlloc_Loop:
        CMP EBX, EAX
        JB R_MemAlloc_End
        CALL RR_PageRegisterUser
        CMP EBX, 0
        JZ R_MemAlloc_End
        SUB EBX, 0x1000
        JMP R_MemAlloc_Loop

    R_MemAlloc_End:
    POP EBX
    RETF
    RR_PageRegisterUser:
        PageRegisterUser
        RET
    ALIGN 16
R_Mfree:
	;; ...
	RETF
	ALIGN 16
R_DiskReadLBA28:;eax=start, ds:ebx=buffer
	HdiskLoadLBA28 EAX,1
	RETF
	ALIGN 16
R_PrintDwordCursor:
	PUSHAD
	PUSH EAX
	MOV EAX, SegVideo
	MOV ES, EAX
	POP EAX
	PUSH DX
	ConCursor; Volatile{DX}
	POP DX
	AND EAX, 0xFFFF
	DbgEcho32 EDX, EAX
	ADD AX,8
	ConCursor AX
	POPAD
	RETF
	ALIGN 16
RoutineEnd:

;[Interrupts protect-32 mode]
Timer_70HINTHandler:
	PUSHAD
	PUSH DS
	MOV AX, SegData
	MOV DS, EAX
	;{ISSUE} Why these codes make interrupt only once? --@dosconio 2024/Jan/17
		; PUSH WORD SegData
		; POP DS
	MOV ESI, THISF_ADR+msg_on_1s
	MOV EDI, 1
	;;CALL SegGate:0
	;
	CALL FAR [THISF_ADR+TSSCrt-4]
	MOV AX, [THISF_ADR+TSSMax]
	MOV BX, [THISF_ADR+TSSCrt]
	ADD BX, 8*2
	CMP BX, AX
	JBE Timer_70HINTHandler_Next0
	MOV BX, 8*0x11
    Timer_70HINTHandler_Next0:
	MOV WORD[THISF_ADR+TSSCrt], BX
	;
	POP DS
	MOV AL, 0x20; EOI
	OUT 0xA0, AL; SLAVE
	OUT 0x20, AL; MASTER
	; OPEN NMI AFTER READ REG-C, OR ONLY INT ONCE
	MOV AL, 0X0C
	OUT 0X70, AL
	IN AL, 0x71
	POPAD
	IRETD
GeneralExceptionHandler:
	MOV EAX, SegData
	MOV DS, EAX
	MOV ESI, THISF_ADR+msg_general_exception
	MOV EDI, RotPrint
	CALL SegGate:0
	DbgStop
GeneralInterruptHandler:
	PUSH EAX
	MOV AL, 0x20; EOI
	OUT 0xA0, AL; SLAVE
	OUT 0x20, AL; MASTER
	POP EAX
	IRETD
